<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis学习篇</title>
    <url>//%5Bobject%20Object%5D/2023/08/04/SDS/</url>
    <content><![CDATA[<h1 id="SDS（Simple-Dynamic-String）"><a href="#SDS（Simple-Dynamic-String）" class="headerlink" title="SDS（Simple Dynamic String）"></a>SDS（Simple Dynamic String）</h1><blockquote>
<p>注：基于redis版本6.0</p>
</blockquote>
<p>SDS是Redis提供的字符串的封装。SDS也兼容部分C字符串API（strcmp，strlen）</p>
<blockquote>
<blockquote>
<p>1.C语言中也算支持String了，为什么Redis还要自己封装一个？</p>
<p>2.SDS的数据结构是啥样的？为什么这样设计？</p>
<p>3.SDS是如何兼容C字符串的？</p>
</blockquote>
</blockquote>
<h3 id="一-sdshdr数据结构"><a href="#一-sdshdr数据结构" class="headerlink" title="一 sdshdr数据结构"></a>一 sdshdr数据结构</h3><hr>
<p>Redis提供了<font color="red">sdshdr5</font>,<font color="red">sdshdr8</font>,<font color="red">sdshdr16</font>,<font color="red">sdshdr32</font>,<font color="red">sdshdr64</font>这几种sds的实现.其中处理sdshdr比较特殊意外,其他几种sdshdr差不只在于字段类型差别,以sdshdr8和sdshdr16举例,源码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 实际上这个类型redis不会被使用。他的内部结构也与其他sdshdr不同，直接看sdshdr8就好。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span><span class="comment">/* 一共8位，低3位用来存放真实的flags(类型),高5位用来存放len(长度)。*/</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span><span class="comment">/*表示当前sds的长度(单位是字节)*/</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span> <span class="comment">/*表示已为sds分配的内存大小(单位是字节)*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span><span class="comment">/* 用一个字节表示当前sdshdr的类型，因为有sdshdr有五种类型，所以至少需要3位来表示。000:sdshdr5，001:sdshdr8，010:sdshdr16，011:sdshdr32，100:sdshdr64。高5位用不到所以都为0。*/</span></span><br><span class="line">    <span class="type">char</span> buf[]; <span class="comment">/* sds实际存放的位置 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><font color="red">msb</font>:Most Significant Bit(最高有效应);<font color="red">lsb</font>:Least Significant Bit(最低有效应).</li>
<li>使用 _attribute_ ((_packed_)) 声明结构体的作用: 让编译器以 <font color="red">紧凑模式</font> 来分配内存,如果不声明该属性,编译器可能会为结构体成员做内存对齐优化,在其中填充空字符,这样就不能保证结构体成员在内存上紧凑相邻的,也不能通过buf数组向低地址偏移一个字节来获取flags字段的值.</li>
<li>char buf[]: 一个没有指定长度的字符数组,这是C语言定义字符数组的一种特殊写法,称为flexible array member,只能定义在一个结构体的最后一个成员,buf起标记作用,表示在flags字段后面就是一个字段数组,程序在为sdshdr分配内存时,他并不占用内存空间.</li>
<li>sizeof(struct sdshdr8)的大小是 (<font color="red">len</font> + <font color="red">alloc</font> + <font color="red">flags</font>)是因为这个struct拥有一个柔性数组成员buf,柔性数组成员是C99之后引入的一个新feature,这里可以通过sizeof在整个struct给出buf变量的偏移量,从而确定buf的位置.</li>
<li>参数说明： len表示sds当前sds的长度(单位是字节)，不包括’0’终止符，通过len直接获取字符串长度，不需要扫一遍string，这就是封装sds的理由之一； alloc表示当前为sds分配的大小(单位是字节)(3.2以前的版本用的free是表示还剩free字节可用空间)，不包括’0’终止符； flags表示当前sdshdr的类型，声明为char 一共有1个字节(8位)，仅用低三位就可以表示所有5种sdshdr类型(详见上文代码注释)。 要判断一个sds属于什么类型的sdshdr，只需 flags&amp;SDS_TYPE_MASK和SDS_TYPE_n比较即可(之所以需要SDS_TYPE_MASK是因为有sdshdr5这个特例，它的高5位不一定为0，参考上面sdshdr5定义里的代码注释）。</li>
</ol>
</blockquote>
<p>对于<code>sdshdr32</code>,<code>sdshdr64</code>也和上面结构一致,差别只在于len和alloc的数据类型不一样而已.</p>
<p><img src="/[object%20Object]/2023/08/04/SDS/sdshdr.png" alt="sdshdr数据结构"></p>
<p>为什么redis费心费力要提供<code>sdshdr5</code>到<code>sdshdr64</code>这五种SDS呢？</p>
<p>我觉着这只能说明Redis作者抠内存抠到机制，牺牲了代码的简洁性换取了每个sds省下来的几个字节的内存空间。从sds初始化方法<code>sdsnew</code>和<code>sdsnewlen</code>中我们就可以看出，redis在新建sds时需要传如初始化长度，然后根据初始化的长度确定用哪种sdshdr，小于2^8长度的用<code>sdshdr8</code>，这样len和alloc只占用两个字节，比较短字符串可能非常多，所以节省下来的内存还是非常可观的，知道了sds的数据结构和设计原理.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string with the content specified by the &#x27;init&#x27; pointer</span></span><br><span class="line"><span class="comment"> * and &#x27;initlen&#x27;.</span></span><br><span class="line"><span class="comment"> * If NULL is used for &#x27;init&#x27; the string is initialized with zero bytes.</span></span><br><span class="line"><span class="comment"> * If SDS_NOINIT is used, the buffer is left uninitialized;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class="line"><span class="comment"> * even if you create an sds string with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mystring = sdsnewlen(&quot;abc&quot;,3);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can print the string with printf() as there is an implicit \0 at the</span></span><br><span class="line"><span class="comment"> * end of the string. However the string is binary safe and can contain</span></span><br><span class="line"><span class="comment"> * \0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class="line"> </span><br><span class="line">sds _sdsnewlen(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen, <span class="type">int</span> trymalloc) &#123;</span><br><span class="line">    <span class="type">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 【注】：根据初始化的长度确定用哪种sdshdr</span></span><br><span class="line"><span class="comment">    * sdsReqType是一个内部函数，会根据申请的字符串的长度确定对应的sds类型</span></span><br><span class="line"><span class="comment">    *（因为sds5只支持长度为2^5的字符串，sds8只支持长度为2^8的字符串，以此类推 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> type = sdsReqType(initlen); </span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 【注】：这里是一个优化，当initlen为0的时候，意味着要申请一个空sds，</span></span><br><span class="line"><span class="comment">    * 空字符串大概率之后会append，但sdshdr5不适合用来append，</span></span><br><span class="line"><span class="comment">    * 这个时候sds8会在这方面表现得更好</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="type">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    <span class="type">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    assert(initlen + hdrlen + <span class="number">1</span> &gt; initlen); <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line">    <span class="comment">/* 【注】</span></span><br><span class="line"><span class="comment">    * s_trymalloc_usable（）尝试分配内存，如果失败，则返回NULL。 如果非NULL，则将&#x27;* usable&#x27;设置为可用大小。</span></span><br><span class="line"><span class="comment">    * s_malloc_usable（）分配内存或紧急/异常情况。 如果非NULL，则将&#x27;* usable&#x27;设置为可用大小。 </span></span><br><span class="line"><span class="comment">    * 具体函数 请查看 (https://github.com/redis/redis/blob/unstable/src/zmalloc.c）*/</span></span><br><span class="line">    sh = trymalloc?</span><br><span class="line">        s_trymalloc_usable(hdrlen+initlen+<span class="number">1</span>, &amp;usable) :</span><br><span class="line">        s_malloc_usable(hdrlen+initlen+<span class="number">1</span>, &amp;usable);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// SDS_NOINIT==&quot;SDS_NOINIT&quot;，如果init是这个字符串，则不对sds进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line"> 	<span class="comment">/* 【**注意**】：返回的s并不是直接指向sds的指针，而是指向sds中字符串的指针，</span></span><br><span class="line"><span class="comment"> 	 * sds的指针还需要根据s和hdrlen计算出来，</span></span><br><span class="line"><span class="comment">     * s为sds中buf的起始位置*/</span></span><br><span class="line">     * </span><br><span class="line">    s = (<span class="type">char</span>*)sh+hdrlen;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fp是sds中flags的指针 */</span></span><br><span class="line">    </span><br><span class="line">    fp = ((<span class="type">unsigned</span> <span class="type">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    usable = usable-hdrlen<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这个是由sds5的规定确定的，sds5中flags低三位是类型，高五位是字符串长度。</span></span><br><span class="line"><span class="comment">    * 所以将initlen偏移三位后，initlen就会移到高五位，</span></span><br><span class="line"><span class="comment">    * 再和type或一下，低三位就是type（目前也只有sds5是这样用，所以低三位就只会是0了） */</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将init字符串的initlen个字节赋值给sds底层char */</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 对 _sdsnewlen 的上层封装。*/</span></span><br><span class="line">sds <span class="title function_">sdsnewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _sdsnewlen(init, initlen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 对 _sdsnewlen 的上层封装。和 sdsnewlen() 的区别是：</span></span><br><span class="line"><span class="comment">* sdstrynewlen() 如果分配内存失败，则返回 null</span></span><br><span class="line"><span class="comment">* sdsnewlen（）： 如果分配内存失败，则抛出异常 ：zmalloc:尝试分配%zu 字节时内存不足</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">sds <span class="title function_">sdstrynewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _sdsnewlen(init, initlen, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>流程如下：</p>
<ul>
<li>根据sds的长度判断需要选用sds的类型</li>
<li>根据sdshdr的类型用sdsHdrSize函数得到hdrlen（其实就是sizeof（struct sdshdr））</li>
<li>为sdshdr分配一个hdrlen + initlen + 1大小的堆内存（+1是为了放置’\0’不计入alloc或len）</li>
<li>按参数填充成员len、alloc和type</li>
<li>用memcpy给sds复制，并在尾部加上’\0’</li>
<li>_sdsnewlen()返回的sds指针并不是直接指向sdshdr的地址而是直接指向sdshdr中buf的地址</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an empty (zero length) sds string. Even in this case the string</span></span><br><span class="line"><span class="comment"> * always has an implicit null term. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个空的（零长度）sds字符串。 即使在这种情况下，字符串总是有一个隐含的空项。*/</span></span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdsempty</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个新的SDS字符串从空开始终止的C字符串 */</span></span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdsnew</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Duplicate an sds string. */</span></span><br><span class="line"><span class="comment">/* 复制一个sds字符串。*/</span></span><br><span class="line">sds <span class="title function_">sdsdup</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free an sds string. No operation is performed if &#x27;s&#x27; is NULL. */</span></span><br><span class="line"><span class="comment">/* 释放一个SDS字符串。 如果“s”为NULL，则不执行任何操作。 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsfree</span><span class="params">(sds s)</span> &#123;s</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(s == <span class="literal">NULL</span>)</span> <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="type">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二、SDS的使用"><a href="#二、SDS的使用" class="headerlink" title="二、SDS的使用"></a>二、SDS的使用</h3><hr>
<p>由于_sdsnewlen()返回的sds并不止直接指向sdshdr的地址，而是直接指向sdshdr中buf的地址。</p>
<p>好处是：可以兼容C原生字符串。buf其实就是C原生字符串 + 部分空余空间，中间是特殊符号’0’隔开，’0’有时表示C字符串末尾的符号，这样就是实现了和C原生字符串的兼容，部分C字符串的API可以直接使用。</p>
<p>坏处是：不能直接拿到len和alloc的具体值，但可以间接拿到</p>
<blockquote>
<p>假设：我们对sds一无所知，但是我们可以往回退一个字节，由于前一个字节是flag，根据flag可以推断出该sds的len和alloc</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdslen</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags = s[<span class="number">-1</span>]; <span class="comment">/* -1 相当于获取到了sdshdr中的flag字段 */</span></span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdsavail</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len; <span class="comment">/* 宏替换获取到sdshdr中的len */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么s[-1]可以拿到flag？</p>
<ol>
<li>由于sdshdr结构体类禁用了内存对齐。</li>
<li>s是指向buf，类型为char，而flags的类型也是char，故s[-1]指向flag，这里的-1就是-1*sizeof（char）</li>
</ol>
</blockquote>
<h3 id="三、SDS扩容"><a href="#三、SDS扩容" class="headerlink" title="三、SDS扩容"></a>三、SDS扩容</h3><hr>
<p>注意：字符串的拼接操作是十分频繁的，在C语言开发中使用<font color="red">char <em>strcat(char </em>dest, const char *src)</font>方法将src字符串中的内容拼接到dest字符串的末尾。由于C语言字符串不记录自身的长度，所有strcat方法已经认为用户在执行此函数时已经为dest分配了足够多的内存，足以容纳src字符串中的所有内容，而一旦条件不成立就会产生缓冲区溢出，会把其他数据覆盖带哦。</p>
<p><img src="/[object%20Object]/2023/08/04/SDS/dest溢出.png" alt="dest溢出"></p>
<p>与C语言字符串不同，SDS的自动扩容机制杜绝发生缓冲区溢出的可能性：</p>
<blockquote>
<p>当SDS API需要对SDS进行修改时，API会先检查SDS的空间时候满足修改所需的要求，如果不满足于，API会自动将SDS的空间扩展之执行修改所需的大小，然后才执行实际的修改，所以SDS既不需要手动去修改SDS的空间大小，也不会出现缓冲区溢出问题。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdscatsds</span><span class="params">(sds s, <span class="type">const</span> sds t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* s: 源字符串</span></span><br><span class="line"><span class="comment"> * t: 待拼接字符串</span></span><br><span class="line"><span class="comment"> * len: 待拼接字符串长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sds <span class="title function_">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取源字符串长度</span></span><br><span class="line">    <span class="type">size_t</span> curlen = sdslen(s);</span><br><span class="line">		<span class="comment">// SDS 分配空间（自动扩容机制）</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将目标字符串拷贝至源字符串末尾</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">// 更新 SDS 长度</span></span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    <span class="comment">// 追加结束符</span></span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自动扩容机制—sdsMakeRoomFor方法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* s: 源字符串</span></span><br><span class="line"><span class="comment"> * addlen: 新增长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sds <span class="title function_">sdsMakeRoomFor</span><span class="params">(sds s, <span class="type">size_t</span> addlen)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *sh, *newsh;</span><br><span class="line">    <span class="comment">// sdsavail: s-&gt;alloc - s-&gt;len, 获取 SDS 的剩余长度</span></span><br><span class="line">    <span class="type">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="type">size_t</span> len, newlen, reqlen;</span><br><span class="line">    <span class="comment">// 根据 flags 获取 SDS 的类型 oldtype</span></span><br><span class="line">    <span class="type">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="type">int</span> hdrlen;</span><br><span class="line">    <span class="type">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="comment">// 剩余空间大于等于新增空间，无需扩容，直接返回源字符串</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">// 获取当前长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sh = (<span class="type">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    <span class="comment">// 新长度</span></span><br><span class="line">    reqlen = newlen = (len+addlen);</span><br><span class="line">    <span class="comment">// 断言新长度比原长度长，否则终止执行</span></span><br><span class="line">    assert(newlen &gt; len);   <span class="comment">/* 防止数据溢出 */</span></span><br><span class="line">    <span class="comment">// SDS_MAX_PREALLOC = 1024*1024, 即1MB</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 新增后长度小于 1MB ，则按新长度的两倍扩容</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 新增后长度大于 1MB ，则按新长度加上 1MB 扩容</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// 重新计算 SDS 的类型</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="comment">// 不使用 sdshdr5 </span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line">    <span class="comment">// 获取新的 header 大小</span></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    assert(hdrlen + newlen + <span class="number">1</span> &gt; reqlen);  <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        <span class="comment">// 类型没变</span></span><br><span class="line">        <span class="comment">// 调用 s_realloc_usable 重新分配可用内存，返回新 SDS 的头部指针</span></span><br><span class="line">        <span class="comment">// usable 会被设置为当前分配的大小</span></span><br><span class="line">        newsh = s_realloc_usable(sh, hdrlen+newlen+<span class="number">1</span>, &amp;usable);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 分配失败直接返回NULL</span></span><br><span class="line">        <span class="comment">// 获取指向 buf 的指针</span></span><br><span class="line">        s = (<span class="type">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 类型变化导致 header 的大小也变化，需要向前移动字符串，不能使用 realloc</span></span><br><span class="line">        newsh = s_malloc_usable(hdrlen+newlen+<span class="number">1</span>, &amp;usable);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 将原字符串copy至新空间中</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放原字符串内存</span></span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="type">char</span>*)newsh+hdrlen;</span><br><span class="line">        <span class="comment">// 更新 SDS 类型</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        <span class="comment">// 设置长度</span></span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 buf 总长度(待定)</span></span><br><span class="line">    usable = usable-hdrlen<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        <span class="comment">// 若可用空间大于当前类型支持的最大长度则截断</span></span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line">    <span class="comment">// 设置 buf 总长度</span></span><br><span class="line">    sdssetalloc(s, usable);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>若SDS中剩余空闲空间avail大于新增内容的长度addlen，这无需扩容。</li>
<li>若SDS中剩余空闲空间avail小于或等于新增内容addlen：<ul>
<li>若新增后总长度len + addlen &lt; 1M,则按新长度的两倍扩容。</li>
<li>若新增后总长度len + addlen &lt; 1M,则按新长度加上1M扩容。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/[object%20Object]/2023/08/04/SDS/SDS自动扩容流程图.png" style="zoom: 67%;"></p>
<blockquote>
<p>扩容后的SDS不会恰好容纳新增的字符，而是多分配了一些空间（预分配策略），这减少了修改字符串时带来的内存重分配次数</p>
</blockquote>
<h3 id="四、内存重分配次数优化"><a href="#四、内存重分配次数优化" class="headerlink" title="四、内存重分配次数优化"></a>四、内存重分配次数优化</h3><hr>
<ol>
<li><p><strong>空间预分配策略</strong></p>
<blockquote>
<p>因为SDS的空间预分配策略，SDS字符串在增长过程中不会频繁的进行空间分配。通过这种分配策略，SDS将持续增长N次字符串所需要的内存重分配次数从必定N次降低为最多N次。</p>
</blockquote>
</li>
<li><p><strong>惰性空间释放机制</strong></p>
<blockquote>
<p>空间预分配策略用户优化SDS增长频繁进行空间分配，而惰性释放机制则用于优化SDS字符串缩短时并不立即使用内存分配策略来回收缩短后多出来的空间，而仅仅更新SDS的len属性，多出来的空间公以后使用。</p>
</blockquote>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sdstrim 方法删除字符串首尾中在 cset 中出现过的字符</span></span><br><span class="line"><span class="comment"> * 比如:</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;AA...AA.a.aa.aHelloWorld     :::&quot;);</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,&quot;Aa. :&quot;);</span></span><br><span class="line"><span class="comment"> * printf(&quot;%s\n&quot;, s);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SDS 变成了 &quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sds <span class="title function_">sdstrim</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *cset)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// strchr()函数用于查找给定字符串中某一个特定字符</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != sp) memmove(s, sp, len);</span><br><span class="line">    s[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 仅仅更新了len</span></span><br><span class="line">    sdssetlen(s,len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于没有真正释放空间，也不会导致内存泄露</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *sh, *newsh;</span><br><span class="line">    <span class="comment">// 获取类型</span></span><br><span class="line">    <span class="type">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="comment">// 获取 header 大小</span></span><br><span class="line">    <span class="type">int</span> hdrlen, oldhdrlen = sdsHdrSize(oldtype);</span><br><span class="line">    <span class="comment">// 获取原字符串长度</span></span><br><span class="line">    <span class="type">size_t</span> len = sdslen(s);</span><br><span class="line">    <span class="comment">// 获取可用长度</span></span><br><span class="line">    <span class="type">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="comment">// 获取指向头部的指针</span></span><br><span class="line">    sh = (<span class="type">char</span>*)s-oldhdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is no space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找适合这个字符串长度的最优 SDS 类型</span></span><br><span class="line">    type = sdsReqType(len);</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果类型相同，或者至少仍然需要一个足够大的类型，我们只需 realloc buf即可；</span></span><br><span class="line"><span class="comment">     * 否则，说明变化很大，则手动重新分配字符串以使用不同的头文件类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type || type &gt; SDS_TYPE_8) &#123;</span><br><span class="line">        newsh = s_realloc(sh, oldhdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="type">char</span>*)newsh+oldhdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="type">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新设置总长度为len</span></span><br><span class="line">    sdssetalloc(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Redis <font color="blue">最大的字符串容量512MB</font>,在redis3.x版本中len时使用int修饰的</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>//%5Bobject%20Object%5D/2023/05/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
